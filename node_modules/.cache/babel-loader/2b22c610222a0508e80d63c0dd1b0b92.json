{"ast":null,"code":"import React from\"react\";import Graph from\"./graph\";function Solution(props){var graph=props.mainData;function createAdjMatrix(V){var adjMatrix=[];// create N x N matrix filled with 0 edge weights between all vertices\nfor(var i=0;i<V;i++){adjMatrix.push([]);for(var j=0;j<V;j++){adjMatrix[i].push(0);}}// populate adjacency matrix with correct edge weights\nfor(var i=0;i<graph.length;i++){adjMatrix[graph[i].startNode][graph[i].endNode]=graph[i].edgeWeight;adjMatrix[graph[i].endNode][graph[i].startNode]=graph[i].edgeWeight;}return adjMatrix;}function prims(V){// create adj matrix from graph\nvar adjMatrix=createAdjMatrix(V);// arbitrarily choose initial vertex from graph\nvar vertex=0;// initialize empty edges array and empty MST\nvar MST=[];var edges=[];var visited=[];var minEdge=[null,null,Infinity];// run prims algorithm until we create an MST\n// that contains every vertex from the graph\nwhile(MST.length!==V-1){// mark this vertex as visited\nvisited.push(vertex);// add each edge to list of potential edges\nfor(var r=0;r<V;r++){if(adjMatrix[vertex][r]!==0){edges.push([vertex,r,adjMatrix[vertex][r]]);}}// find edge with the smallest weight to a vertex\n// that has not yet been visited\nfor(var e=0;e<edges.length;e++){if(edges[e][2]<minEdge[2]&&visited.indexOf(edges[e][1])===-1){minEdge=edges[e];}}// remove min weight edge from list of edges\nedges.splice(edges.indexOf(minEdge),1);// push min edge to MST\nMST.push(minEdge);// start at new vertex and reset min edge\nvertex=minEdge[1];minEdge=[null,null,Infinity];}return MST;}// Function call to get the solution\nvar nodeCount=parseInt(props.nodeCount);var solutionArray=prims(nodeCount);function printSolution(ans){return/*#__PURE__*/React.createElement(\"h4\",null,\"Node \",ans[0],\" to \",ans[1],\" having edge weight \",ans[2]);}return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"h2\",null,\"Solution :\"),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(\"h3\",null,\"Number of Nodes : \",props.nodeCount),/*#__PURE__*/React.createElement(\"h3\",null,\"Minimum spanning tree has the following nodes: \"),/*#__PURE__*/React.createElement(\"br\",null),solutionArray.map(printSolution),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(Graph,{data:solutionArray,n:props.nodeCount}));}export default Solution;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/GreedyAssignment/assignment/src/MST/solution.js"],"names":["React","Graph","Solution","props","graph","mainData","createAdjMatrix","V","adjMatrix","i","push","j","length","startNode","endNode","edgeWeight","prims","vertex","MST","edges","visited","minEdge","Infinity","r","e","indexOf","splice","nodeCount","parseInt","solutionArray","printSolution","ans","map"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport Graph from \"./graph\";\r\n\r\n\r\nfunction Solution(props){\r\n\r\n    var graph= props.mainData;\r\n    \r\n    function createAdjMatrix(V) {\r\n  \r\n        var adjMatrix = [];\r\n        \r\n        // create N x N matrix filled with 0 edge weights between all vertices\r\n        for (var i = 0; i < V; i++) { \r\n          adjMatrix.push([]);\r\n          for (var j = 0; j < V; j++) { adjMatrix[i].push(0); }\r\n        }\r\n        \r\n        // populate adjacency matrix with correct edge weights\r\n        for (var i = 0; i < graph.length; i++) { \r\n          adjMatrix[graph[i].startNode][graph[i].endNode] = graph[i].edgeWeight;\r\n          adjMatrix[graph[i].endNode][graph[i].startNode] = graph[i].edgeWeight;\r\n        }\r\n        \r\n        return adjMatrix;\r\n        \r\n      }\r\n      \r\n      function prims(V) {\r\n        \r\n        // create adj matrix from graph\r\n        var adjMatrix = createAdjMatrix(V);\r\n        \r\n        // arbitrarily choose initial vertex from graph\r\n        var vertex = 0;\r\n        \r\n        // initialize empty edges array and empty MST\r\n        var MST = [];\r\n        var edges = [];\r\n        var visited = [];\r\n        var minEdge = [null,null,Infinity];\r\n        \r\n        // run prims algorithm until we create an MST\r\n        // that contains every vertex from the graph\r\n        while (MST.length !== V-1) {\r\n          \r\n          // mark this vertex as visited\r\n          visited.push(vertex);\r\n          \r\n          // add each edge to list of potential edges\r\n          for (var r = 0; r < V; r++) {\r\n            if (adjMatrix[vertex][r] !== 0) { \r\n              edges.push([vertex,r,adjMatrix[vertex][r]]); \r\n            }\r\n          }\r\n      \r\n          // find edge with the smallest weight to a vertex\r\n          // that has not yet been visited\r\n          for (var e = 0; e < edges.length; e++) {\r\n            if (edges[e][2] < minEdge[2] && visited.indexOf(edges[e][1]) === -1) { \r\n              minEdge = edges[e]; \r\n            }\r\n          }\r\n      \r\n          // remove min weight edge from list of edges\r\n          edges.splice(edges.indexOf(minEdge), 1);\r\n      \r\n          // push min edge to MST\r\n          MST.push(minEdge);\r\n            \r\n          // start at new vertex and reset min edge\r\n          vertex = minEdge[1];\r\n          minEdge = [null,null,Infinity];\r\n          \r\n        }\r\n        \r\n        return MST;\r\n        \r\n      }\r\n    \r\n// Function call to get the solution\r\n      var nodeCount= parseInt(props.nodeCount)\r\n      var solutionArray= (prims(nodeCount));\r\n\r\n      function printSolution(ans){\r\n          return (\r\n              <h4>\r\n                Node {ans[0]} to {ans[1]} having edge weight {ans[2]}\r\n              </h4>\r\n          )\r\n      }\r\n\r\n\r\n    return(\r\n        <div>\r\n            <h2>Solution :</h2>\r\n            <br></br>\r\n            <h3>Number of Nodes : {props.nodeCount}</h3>\r\n            <h3>Minimum spanning tree has the following nodes: </h3>\r\n            <br></br>\r\n            {solutionArray.map(printSolution)}\r\n            <br></br>\r\n            <br></br>\r\n            <br></br>\r\n            <Graph\r\n              \r\n              data= {solutionArray}\r\n              n= {props.nodeCount}\r\n            />\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Solution;"]},"metadata":{},"sourceType":"module"}