{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\GreedyAssignment\\\\assignment\\\\src\\\\MST\\\\solution.js\";\nimport React from \"react\";\nimport Graph from \"./graph\";\n\nfunction Solution(props) {\n  var graph = props.mainData;\n\n  function createAdjMatrix(V) {\n    var adjMatrix = []; // create N x N matrix filled with 0 edge weights between all vertices\n\n    for (var i = 0; i < V; i++) {\n      adjMatrix.push([]);\n\n      for (var j = 0; j < V; j++) {\n        adjMatrix[i].push(0);\n      }\n    } // populate adjacency matrix with correct edge weights\n\n\n    for (var i = 0; i < graph.length; i++) {\n      adjMatrix[graph[i].startNode][graph[i].endNode] = graph[i].edgeWeight;\n      adjMatrix[graph[i].endNode][graph[i].startNode] = graph[i].edgeWeight;\n    }\n\n    return adjMatrix;\n  }\n\n  function prims(V) {\n    // create adj matrix from graph\n    var adjMatrix = createAdjMatrix(V); // arbitrarily choose initial vertex from graph\n\n    var vertex = 0; // initialize empty edges array and empty MST\n\n    var MST = [];\n    var edges = [];\n    var visited = [];\n    var minEdge = [null, null, Infinity]; // run prims algorithm until we create an MST\n    // that contains every vertex from the graph\n\n    while (MST.length !== V - 1) {\n      // mark this vertex as visited\n      visited.push(vertex); // add each edge to list of potential edges\n\n      for (var r = 0; r < V; r++) {\n        if (adjMatrix[vertex][r] !== 0) {\n          edges.push([vertex, r, adjMatrix[vertex][r]]);\n        }\n      } // find edge with the smallest weight to a vertex\n      // that has not yet been visited\n\n\n      for (var e = 0; e < edges.length; e++) {\n        if (edges[e][2] < minEdge[2] && visited.indexOf(edges[e][1]) === -1) {\n          minEdge = edges[e];\n        }\n      } // remove min weight edge from list of edges\n\n\n      edges.splice(edges.indexOf(minEdge), 1); // push min edge to MST\n\n      MST.push(minEdge); // start at new vertex and reset min edge\n\n      vertex = minEdge[1];\n      minEdge = [null, null, Infinity];\n    }\n\n    return MST;\n  } // Function call to get the solution\n\n\n  var nodeCount = parseInt(props.nodeCount);\n  var solutionArray = prims(nodeCount);\n\n  function printSolution(ans) {\n    return /*#__PURE__*/React.createElement(\"h4\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 87,\n        columnNumber: 15\n      }\n    }, \"Node \", ans[0], \" to \", ans[1], \" having edge weight \", ans[2]);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 13\n    }\n  }, \"Solution :\"), /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 13\n    }\n  }), /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 13\n    }\n  }, \"Number of Nodes : \", props.nodeCount), /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 13\n    }\n  }, \"Minimum spanning tree has the following nodes: \"), /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 13\n    }\n  }), solutionArray.map(printSolution), /*#__PURE__*/React.createElement(Graph, {\n    data: solutionArray,\n    n: props.nodeCount,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 13\n    }\n  }));\n}\n\nexport default Solution;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/GreedyAssignment/assignment/src/MST/solution.js"],"names":["React","Graph","Solution","props","graph","mainData","createAdjMatrix","V","adjMatrix","i","push","j","length","startNode","endNode","edgeWeight","prims","vertex","MST","edges","visited","minEdge","Infinity","r","e","indexOf","splice","nodeCount","parseInt","solutionArray","printSolution","ans","map"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,KAAP,MAAkB,SAAlB;;AAGA,SAASC,QAAT,CAAkBC,KAAlB,EAAwB;AAEpB,MAAIC,KAAK,GAAED,KAAK,CAACE,QAAjB;;AAEA,WAASC,eAAT,CAAyBC,CAAzB,EAA4B;AAExB,QAAIC,SAAS,GAAG,EAAhB,CAFwB,CAIxB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAApB,EAAuBE,CAAC,EAAxB,EAA4B;AAC1BD,MAAAA,SAAS,CAACE,IAAV,CAAe,EAAf;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;AAAEH,QAAAA,SAAS,CAACC,CAAD,CAAT,CAAaC,IAAb,CAAkB,CAAlB;AAAuB;AACtD,KARuB,CAUxB;;;AACA,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACQ,MAA1B,EAAkCH,CAAC,EAAnC,EAAuC;AACrCD,MAAAA,SAAS,CAACJ,KAAK,CAACK,CAAD,CAAL,CAASI,SAAV,CAAT,CAA8BT,KAAK,CAACK,CAAD,CAAL,CAASK,OAAvC,IAAkDV,KAAK,CAACK,CAAD,CAAL,CAASM,UAA3D;AACAP,MAAAA,SAAS,CAACJ,KAAK,CAACK,CAAD,CAAL,CAASK,OAAV,CAAT,CAA4BV,KAAK,CAACK,CAAD,CAAL,CAASI,SAArC,IAAkDT,KAAK,CAACK,CAAD,CAAL,CAASM,UAA3D;AACD;;AAED,WAAOP,SAAP;AAED;;AAED,WAASQ,KAAT,CAAeT,CAAf,EAAkB;AAEhB;AACA,QAAIC,SAAS,GAAGF,eAAe,CAACC,CAAD,CAA/B,CAHgB,CAKhB;;AACA,QAAIU,MAAM,GAAG,CAAb,CANgB,CAQhB;;AACA,QAAIC,GAAG,GAAG,EAAV;AACA,QAAIC,KAAK,GAAG,EAAZ;AACA,QAAIC,OAAO,GAAG,EAAd;AACA,QAAIC,OAAO,GAAG,CAAC,IAAD,EAAM,IAAN,EAAWC,QAAX,CAAd,CAZgB,CAchB;AACA;;AACA,WAAOJ,GAAG,CAACN,MAAJ,KAAeL,CAAC,GAAC,CAAxB,EAA2B;AAEzB;AACAa,MAAAA,OAAO,CAACV,IAAR,CAAaO,MAAb,EAHyB,CAKzB;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,CAApB,EAAuBgB,CAAC,EAAxB,EAA4B;AAC1B,YAAIf,SAAS,CAACS,MAAD,CAAT,CAAkBM,CAAlB,MAAyB,CAA7B,EAAgC;AAC9BJ,UAAAA,KAAK,CAACT,IAAN,CAAW,CAACO,MAAD,EAAQM,CAAR,EAAUf,SAAS,CAACS,MAAD,CAAT,CAAkBM,CAAlB,CAAV,CAAX;AACD;AACF,OAVwB,CAYzB;AACA;;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACP,MAA1B,EAAkCY,CAAC,EAAnC,EAAuC;AACrC,YAAIL,KAAK,CAACK,CAAD,CAAL,CAAS,CAAT,IAAcH,OAAO,CAAC,CAAD,CAArB,IAA4BD,OAAO,CAACK,OAAR,CAAgBN,KAAK,CAACK,CAAD,CAAL,CAAS,CAAT,CAAhB,MAAiC,CAAC,CAAlE,EAAqE;AACnEH,UAAAA,OAAO,GAAGF,KAAK,CAACK,CAAD,CAAf;AACD;AACF,OAlBwB,CAoBzB;;;AACAL,MAAAA,KAAK,CAACO,MAAN,CAAaP,KAAK,CAACM,OAAN,CAAcJ,OAAd,CAAb,EAAqC,CAArC,EArByB,CAuBzB;;AACAH,MAAAA,GAAG,CAACR,IAAJ,CAASW,OAAT,EAxByB,CA0BzB;;AACAJ,MAAAA,MAAM,GAAGI,OAAO,CAAC,CAAD,CAAhB;AACAA,MAAAA,OAAO,GAAG,CAAC,IAAD,EAAM,IAAN,EAAWC,QAAX,CAAV;AAED;;AAED,WAAOJ,GAAP;AAED,GA1EiB,CA4ExB;;;AACM,MAAIS,SAAS,GAAEC,QAAQ,CAACzB,KAAK,CAACwB,SAAP,CAAvB;AACA,MAAIE,aAAa,GAAGb,KAAK,CAACW,SAAD,CAAzB;;AAEA,WAASG,aAAT,CAAuBC,GAAvB,EAA2B;AACvB,wBACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBACQA,GAAG,CAAC,CAAD,CADX,UACoBA,GAAG,CAAC,CAAD,CADvB,0BACgDA,GAAG,CAAC,CAAD,CADnD,CADJ;AAKH;;AAGH,sBACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBADJ,eAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAFJ,eAGI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAAuB5B,KAAK,CAACwB,SAA7B,CAHJ,eAII;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uDAJJ,eAKI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IALJ,EAMKE,aAAa,CAACG,GAAd,CAAkBF,aAAlB,CANL,eAOI,oBAAC,KAAD;AACE,IAAA,IAAI,EAAGD,aADT;AAEE,IAAA,CAAC,EAAG1B,KAAK,CAACwB,SAFZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAPJ,CADJ;AAeH;;AAED,eAAezB,QAAf","sourcesContent":["import React from \"react\";\r\nimport Graph from \"./graph\";\r\n\r\n\r\nfunction Solution(props){\r\n\r\n    var graph= props.mainData;\r\n    \r\n    function createAdjMatrix(V) {\r\n  \r\n        var adjMatrix = [];\r\n        \r\n        // create N x N matrix filled with 0 edge weights between all vertices\r\n        for (var i = 0; i < V; i++) { \r\n          adjMatrix.push([]);\r\n          for (var j = 0; j < V; j++) { adjMatrix[i].push(0); }\r\n        }\r\n        \r\n        // populate adjacency matrix with correct edge weights\r\n        for (var i = 0; i < graph.length; i++) { \r\n          adjMatrix[graph[i].startNode][graph[i].endNode] = graph[i].edgeWeight;\r\n          adjMatrix[graph[i].endNode][graph[i].startNode] = graph[i].edgeWeight;\r\n        }\r\n        \r\n        return adjMatrix;\r\n        \r\n      }\r\n      \r\n      function prims(V) {\r\n        \r\n        // create adj matrix from graph\r\n        var adjMatrix = createAdjMatrix(V);\r\n        \r\n        // arbitrarily choose initial vertex from graph\r\n        var vertex = 0;\r\n        \r\n        // initialize empty edges array and empty MST\r\n        var MST = [];\r\n        var edges = [];\r\n        var visited = [];\r\n        var minEdge = [null,null,Infinity];\r\n        \r\n        // run prims algorithm until we create an MST\r\n        // that contains every vertex from the graph\r\n        while (MST.length !== V-1) {\r\n          \r\n          // mark this vertex as visited\r\n          visited.push(vertex);\r\n          \r\n          // add each edge to list of potential edges\r\n          for (var r = 0; r < V; r++) {\r\n            if (adjMatrix[vertex][r] !== 0) { \r\n              edges.push([vertex,r,adjMatrix[vertex][r]]); \r\n            }\r\n          }\r\n      \r\n          // find edge with the smallest weight to a vertex\r\n          // that has not yet been visited\r\n          for (var e = 0; e < edges.length; e++) {\r\n            if (edges[e][2] < minEdge[2] && visited.indexOf(edges[e][1]) === -1) { \r\n              minEdge = edges[e]; \r\n            }\r\n          }\r\n      \r\n          // remove min weight edge from list of edges\r\n          edges.splice(edges.indexOf(minEdge), 1);\r\n      \r\n          // push min edge to MST\r\n          MST.push(minEdge);\r\n            \r\n          // start at new vertex and reset min edge\r\n          vertex = minEdge[1];\r\n          minEdge = [null,null,Infinity];\r\n          \r\n        }\r\n        \r\n        return MST;\r\n        \r\n      }\r\n    \r\n// Function call to get the solution\r\n      var nodeCount= parseInt(props.nodeCount)\r\n      var solutionArray= (prims(nodeCount));\r\n\r\n      function printSolution(ans){\r\n          return (\r\n              <h4>\r\n                Node {ans[0]} to {ans[1]} having edge weight {ans[2]}\r\n              </h4>\r\n          )\r\n      }\r\n\r\n\r\n    return(\r\n        <div>\r\n            <h2>Solution :</h2>\r\n            <br></br>\r\n            <h3>Number of Nodes : {props.nodeCount}</h3>\r\n            <h3>Minimum spanning tree has the following nodes: </h3>\r\n            <br></br>\r\n            {solutionArray.map(printSolution)}\r\n            <Graph\r\n              data= {solutionArray}\r\n              n= {props.nodeCount}\r\n            />\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Solution;"]},"metadata":{},"sourceType":"module"}