{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\GreedyAssignment\\\\assignment\\\\src\\\\MST\\\\solution.js\";\nimport React from \"react\";\n\nfunction Solution(props) {\n  var graph = props.mainData;\n\n  function createAdjMatrix(V, G) {\n    var adjMatrix = []; // create N x N matrix filled with 0 edge weights between all vertices\n\n    for (var i = 0; i < V; i++) {\n      adjMatrix.push([]);\n\n      for (var j = 0; j < V; j++) {\n        adjMatrix[i].push(0);\n      }\n    } // populate adjacency matrix with correct edge weights\n\n\n    for (var i = 0; i < G.length; i++) {\n      adjMatrix[G[i][0]][G[i][1]] = G[i][2];\n      adjMatrix[G[i][1]][G[i][0]] = G[i][2];\n    }\n\n    return adjMatrix;\n  }\n\n  function prims(V, G) {\n    // create adj matrix from graph\n    var adjMatrix = createAdjMatrix(V, G); // arbitrarily choose initial vertex from graph\n\n    var vertex = 0; // initialize empty edges array and empty MST\n\n    var MST = [];\n    var edges = [];\n    var visited = [];\n    var minEdge = [null, null, Infinity]; // run prims algorithm until we create an MST\n    // that contains every vertex from the graph\n\n    while (MST.length !== V - 1) {\n      // mark this vertex as visited\n      visited.push(vertex); // add each edge to list of potential edges\n\n      for (var r = 0; r < V; r++) {\n        if (adjMatrix[vertex][r] !== 0) {\n          edges.push([vertex, r, adjMatrix[vertex][r]]);\n        }\n      } // find edge with the smallest weight to a vertex\n      // that has not yet been visited\n\n\n      for (var e = 0; e < edges.length; e++) {\n        if (edges[e][2] < minEdge[2] && visited.indexOf(edges[e][1]) === -1) {\n          minEdge = edges[e];\n        }\n      } // remove min weight edge from list of edges\n\n\n      edges.splice(edges.indexOf(minEdge), 1); // push min edge to MST\n\n      MST.push(minEdge); // start at new vertex and reset min edge\n\n      vertex = minEdge[1];\n      minEdge = [null, null, Infinity];\n    }\n\n    return MST;\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 13\n    }\n  }, \"Solution :\"), console.log(prims(3, graph)));\n}\n\nexport default Solution;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/GreedyAssignment/assignment/src/MST/solution.js"],"names":["React","Solution","props","graph","mainData","createAdjMatrix","V","G","adjMatrix","i","push","j","length","prims","vertex","MST","edges","visited","minEdge","Infinity","r","e","indexOf","splice","console","log"],"mappings":"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","sourcesContent":["import React from \"react\";\r\n\r\n\r\nfunction Solution(props){\r\n\r\n    var graph= props.mainData;\r\n    \r\n    function createAdjMatrix(V, G) {\r\n  \r\n        var adjMatrix = [];\r\n        \r\n        // create N x N matrix filled with 0 edge weights between all vertices\r\n        for (var i = 0; i < V; i++) { \r\n          adjMatrix.push([]);\r\n          for (var j = 0; j < V; j++) { adjMatrix[i].push(0); }\r\n        }\r\n        \r\n        // populate adjacency matrix with correct edge weights\r\n        for (var i = 0; i < G.length; i++) { \r\n          adjMatrix[G[i][0]][G[i][1]] = G[i][2];\r\n          adjMatrix[G[i][1]][G[i][0]] = G[i][2];\r\n        }\r\n        \r\n        return adjMatrix;\r\n        \r\n      }\r\n      \r\n      function prims(V, G) {\r\n        \r\n        // create adj matrix from graph\r\n        var adjMatrix = createAdjMatrix(V, G);\r\n        \r\n        // arbitrarily choose initial vertex from graph\r\n        var vertex = 0;\r\n        \r\n        // initialize empty edges array and empty MST\r\n        var MST = [];\r\n        var edges = [];\r\n        var visited = [];\r\n        var minEdge = [null,null,Infinity];\r\n        \r\n        // run prims algorithm until we create an MST\r\n        // that contains every vertex from the graph\r\n        while (MST.length !== V-1) {\r\n          \r\n          // mark this vertex as visited\r\n          visited.push(vertex);\r\n          \r\n          // add each edge to list of potential edges\r\n          for (var r = 0; r < V; r++) {\r\n            if (adjMatrix[vertex][r] !== 0) { \r\n              edges.push([vertex,r,adjMatrix[vertex][r]]); \r\n            }\r\n          }\r\n      \r\n          // find edge with the smallest weight to a vertex\r\n          // that has not yet been visited\r\n          for (var e = 0; e < edges.length; e++) {\r\n            if (edges[e][2] < minEdge[2] && visited.indexOf(edges[e][1]) === -1) { \r\n              minEdge = edges[e]; \r\n            }\r\n          }\r\n      \r\n          // remove min weight edge from list of edges\r\n          edges.splice(edges.indexOf(minEdge), 1);\r\n      \r\n          // push min edge to MST\r\n          MST.push(minEdge);\r\n            \r\n          // start at new vertex and reset min edge\r\n          vertex = minEdge[1];\r\n          minEdge = [null,null,Infinity];\r\n          \r\n        }\r\n        \r\n        return MST;\r\n        \r\n      }\r\n    \r\n\r\n    \r\n      \r\n\r\n    return(\r\n        <div>\r\n            <p>Solution :</p>\r\n            {console.log(prims(3, graph))}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Solution;"]},"metadata":{},"sourceType":"module"}