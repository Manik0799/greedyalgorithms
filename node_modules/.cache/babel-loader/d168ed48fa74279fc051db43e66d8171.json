{"ast":null,"code":"import React from\"react\";function Solution(props){function HuffmanEncoding(str){this.str=str;var count_chars={};for(var i=0;i<str.length;i++){if(str[i]in count_chars)count_chars[str[i]]++;else count_chars[str[i]]=1;}var pq=new BinaryHeap(function(x){return x[0];});for(var ch in count_chars){pq.push([count_chars[ch],ch]);}while(pq.size()>1){var pair1=pq.pop();var pair2=pq.pop();pq.push([pair1[0]+pair2[0],[pair1[1],pair2[1]]]);}var tree=pq.pop();this.encoding={};this._generate_encoding(tree[1],\"\");this.encoded_string=\"\";var counter=0;for(var i=0;i<this.str.length;i++){if(counter>=10){counter=0;this.encoded_string+=\"\\n\";}this.encoded_string+=this.encoding[str[i]];counter++;}}HuffmanEncoding.prototype._generate_encoding=function(ary,prefix){if(ary instanceof Array){this._generate_encoding(ary[0],prefix+\"0\");this._generate_encoding(ary[1],prefix+\"1\");}else{this.encoding[ary]=prefix;}};var individualcodes=[];HuffmanEncoding.prototype.inspect_encoding=function(){for(var ch in this.encoding){var sample=\"\";if(ch===\" \"){sample=\"Space\"+\" : \"+this.encoding[ch];}else if(ch===\"\\n\"){sample=\"Enter\"+\" : \"+this.encoding[ch];}else{sample=ch+\" : \"+this.encoding[ch];}individualcodes.push(sample);}};// Binary heap implementation\nfunction BinaryHeap(scoreFunction){this.content=[];this.scoreFunction=scoreFunction;}BinaryHeap.prototype={push:function push(element){// Add the new element to the end of the array.\nthis.content.push(element);// Allow it to bubble up.\nthis.bubbleUp(this.content.length-1);},pop:function pop(){// Store the first element so we can return it later.\nvar result=this.content[0];// Get the element at the end of the array.\nvar end=this.content.pop();// If there are any elements left, put the end element at the\n// start, and let it sink down.\nif(this.content.length>0){this.content[0]=end;this.sinkDown(0);}return result;},remove:function remove(node){var length=this.content.length;// To remove a value, we must search through the array to find\n// it.\nfor(var i=0;i<length;i++){if(this.content[i]!=node)continue;// When it is found, the process seen in 'pop' is repeated\n// to fill up the hole.\nvar end=this.content.pop();// If the element we popped was the one we needed to remove,\n// we're done.\nif(i===length-1)break;// Otherwise, we replace the removed element with the popped\n// one, and allow it to float up or sink down as appropriate.\nthis.content[i]=end;this.bubbleUp(i);this.sinkDown(i);break;}},size:function size(){return this.content.length;},bubbleUp:function bubbleUp(n){// Fetch the element that has to be moved.\nvar element=this.content[n],score=this.scoreFunction(element);// When at 0, an element can not go up any further.\nwhile(n>0){// Compute the parent element's index, and fetch it.\nvar parentN=Math.floor((n+1)/2)-1,parent=this.content[parentN];// If the parent has a lesser score, things are in order and we\n// are done.\nif(score>=this.scoreFunction(parent))break;// Otherwise, swap the parent with the current element and\n// continue.\nthis.content[parentN]=element;this.content[n]=parent;n=parentN;}},sinkDown:function sinkDown(n){// Look up the target element and its score.\nvar length=this.content.length,element=this.content[n],elemScore=this.scoreFunction(element);while(true){// Compute the indices of the child elements.\nvar child2N=(n+1)*2,child1N=child2N-1;// This is used to store the new position of the element,\n// if any.\nvar swap=null;// If the first child exists (is inside the array)...\nif(child1N<length){// Look it up and compute its score.\nvar child1=this.content[child1N],child1Score=this.scoreFunction(child1);// If the score is less than our element's, we need to swap.\nif(child1Score<elemScore)swap=child1N;}// Do the same checks for the other child.\nif(child2N<length){var child2=this.content[child2N],child2Score=this.scoreFunction(child2);if(child2Score<(swap==null?elemScore:child1Score))swap=child2N;}// No need to swap further, we are done.\nif(swap===null)break;// Otherwise, swap and continue.\nthis.content[n]=this.content[swap];this.content[swap]=element;n=swap;}}};var huff=new HuffmanEncoding(props.data);function getCode(){huff.inspect_encoding();}function printcodes(letterCode){return/*#__PURE__*/React.createElement(\"h4\",null,letterCode);}return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"h3\",null,/*#__PURE__*/React.createElement(\"b\",null,\"Original text: \"),\" \",props.data,\" \"),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(\"h3\",null,/*#__PURE__*/React.createElement(\"b\",null,\"Code : \"),\" \",huff.encoded_string),getCode(),/*#__PURE__*/React.createElement(\"br\",null),/*#__PURE__*/React.createElement(\"h3\",null,/*#__PURE__*/React.createElement(\"b\",null,\"Character codes : \"),\" \"),/*#__PURE__*/React.createElement(\"br\",null),individualcodes.map(printcodes));}export default Solution;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/GreedyAssignment/assignment/src/Huffmann/solution.js"],"names":["React","Solution","props","HuffmanEncoding","str","count_chars","i","length","pq","BinaryHeap","x","ch","push","size","pair1","pop","pair2","tree","encoding","_generate_encoding","encoded_string","counter","prototype","ary","prefix","Array","individualcodes","inspect_encoding","sample","scoreFunction","content","element","bubbleUp","result","end","sinkDown","remove","node","n","score","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","child2Score","huff","data","getCode","printcodes","letterCode","map"],"mappings":"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","sourcesContent":["import React from \"react\";\r\n\r\nfunction Solution(props){\r\n\r\n\r\n    function HuffmanEncoding(str) {\r\n        this.str = str;\r\n     \r\n        var count_chars = {};\r\n        for (var i = 0; i < str.length; i++) \r\n            if (str[i] in count_chars) \r\n                count_chars[str[i]] ++;\r\n            else \r\n                count_chars[str[i]] = 1;\r\n     \r\n        var pq = new BinaryHeap(function(x){return x[0];});\r\n        for (var ch in count_chars) \r\n            pq.push([count_chars[ch], ch]);\r\n     \r\n        while (pq.size() > 1) {\r\n            var pair1 = pq.pop();\r\n            var pair2 = pq.pop();\r\n            pq.push([pair1[0]+pair2[0], [pair1[1], pair2[1]]]);\r\n        }\r\n     \r\n        var tree = pq.pop();\r\n        this.encoding = {};\r\n        this._generate_encoding(tree[1], \"\");\r\n     \r\n        this.encoded_string = \"\"\r\n        let counter= 0;\r\n        for (var i = 0; i < this.str.length; i++) {\r\n\r\n          if(counter>=10){\r\n            counter=0;\r\n            this.encoded_string+= \"\\n\";\r\n          }\r\n            this.encoded_string += this.encoding[str[i]];\r\n            counter++;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    HuffmanEncoding.prototype._generate_encoding = function(ary, prefix) {\r\n        if (ary instanceof Array) {\r\n            this._generate_encoding(ary[0], prefix + \"0\");\r\n            this._generate_encoding(ary[1], prefix + \"1\");\r\n        }\r\n        else {\r\n            this.encoding[ary] = prefix;\r\n        }\r\n    }\r\n\r\n    let individualcodes= [];\r\n     \r\n    HuffmanEncoding.prototype.inspect_encoding = function() {\r\n        for (var ch in this.encoding) {\r\n\r\n            let sample= \"\";\r\n            if(ch===\" \"){\r\n                 sample= \"Space\" + \" : \" + this.encoding[ch]\r\n            }else if(ch===\"\\n\"){\r\n                sample= \"Enter\" + \" : \" + this.encoding[ch]\r\n            }\r\n            else{\r\n                 sample=  ch + \" : \" + this.encoding[ch];\r\n            }\r\n            \r\n            individualcodes.push(sample);\r\n        }\r\n    }\r\n\r\n\r\n// Binary heap implementation\r\n    function BinaryHeap(scoreFunction){\r\n        this.content = [];\r\n        this.scoreFunction = scoreFunction;\r\n      }\r\n      \r\n      BinaryHeap.prototype = {\r\n        push: function(element) {\r\n          // Add the new element to the end of the array.\r\n          this.content.push(element);\r\n          // Allow it to bubble up.\r\n          this.bubbleUp(this.content.length - 1);\r\n        },\r\n      \r\n        pop: function() {\r\n          // Store the first element so we can return it later.\r\n          var result = this.content[0];\r\n          // Get the element at the end of the array.\r\n          var end = this.content.pop();\r\n          // If there are any elements left, put the end element at the\r\n          // start, and let it sink down.\r\n          if (this.content.length > 0) {\r\n            this.content[0] = end;\r\n            this.sinkDown(0);\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        remove: function(node) {\r\n          var length = this.content.length;\r\n          // To remove a value, we must search through the array to find\r\n          // it.\r\n          for (var i = 0; i < length; i++) {\r\n            if (this.content[i] != node) continue;\r\n            // When it is found, the process seen in 'pop' is repeated\r\n            // to fill up the hole.\r\n            var end = this.content.pop();\r\n            // If the element we popped was the one we needed to remove,\r\n            // we're done.\r\n            if (i === length - 1) break;\r\n            // Otherwise, we replace the removed element with the popped\r\n            // one, and allow it to float up or sink down as appropriate.\r\n            this.content[i] = end;\r\n            this.bubbleUp(i);\r\n            this.sinkDown(i);\r\n            break;\r\n          }\r\n        },\r\n      \r\n        size: function() {\r\n          return this.content.length;\r\n        },\r\n      \r\n        bubbleUp: function(n) {\r\n          // Fetch the element that has to be moved.\r\n          var element = this.content[n], score = this.scoreFunction(element);\r\n          // When at 0, an element can not go up any further.\r\n          while (n > 0) {\r\n            // Compute the parent element's index, and fetch it.\r\n            var parentN = Math.floor((n + 1) / 2) - 1,\r\n            parent = this.content[parentN];\r\n            // If the parent has a lesser score, things are in order and we\r\n            // are done.\r\n            if (score >= this.scoreFunction(parent))\r\n              break;\r\n      \r\n            // Otherwise, swap the parent with the current element and\r\n            // continue.\r\n            this.content[parentN] = element;\r\n            this.content[n] = parent;\r\n            n = parentN;\r\n          }\r\n        },\r\n      \r\n        sinkDown: function(n) {\r\n          // Look up the target element and its score.\r\n          var length = this.content.length,\r\n          element = this.content[n],\r\n          elemScore = this.scoreFunction(element);\r\n      \r\n          while(true) {\r\n            // Compute the indices of the child elements.\r\n            var child2N = (n + 1) * 2, child1N = child2N - 1;\r\n            // This is used to store the new position of the element,\r\n            // if any.\r\n            var swap = null;\r\n            // If the first child exists (is inside the array)...\r\n            if (child1N < length) {\r\n              // Look it up and compute its score.\r\n              var child1 = this.content[child1N],\r\n              child1Score = this.scoreFunction(child1);\r\n              // If the score is less than our element's, we need to swap.\r\n              if (child1Score < elemScore)\r\n                swap = child1N;\r\n            }\r\n            // Do the same checks for the other child.\r\n            if (child2N < length) {\r\n              var child2 = this.content[child2N],\r\n              child2Score = this.scoreFunction(child2);\r\n              if (child2Score < (swap == null ? elemScore : child1Score))\r\n                swap = child2N;\r\n            }\r\n      \r\n            // No need to swap further, we are done.\r\n            if (swap === null) break;\r\n      \r\n            // Otherwise, swap and continue.\r\n            this.content[n] = this.content[swap];\r\n            this.content[swap] = element;\r\n            n = swap;\r\n          }\r\n        }\r\n      };\r\n\r\n\r\n      var huff = new HuffmanEncoding(props.data);\r\n\r\n      function getCode(){\r\n        \r\n        huff.inspect_encoding();\r\n      }\r\n\r\n\r\n      function printcodes(letterCode){\r\n          return(\r\n              <h4>{letterCode}</h4>\r\n          )\r\n      }\r\n\r\n\r\n\r\n    return(\r\n        <div>\r\n            <h3><b>Original text: </b> {props.data} </h3>\r\n\r\n            <br></br>\r\n            \r\n            \r\n              <h3><b>Code : </b> {huff.encoded_string}</h3>\r\n            \r\n            \r\n            {getCode()}\r\n            <br></br>\r\n            <h3><b>Character codes : </b> </h3>\r\n            <br></br>\r\n            {individualcodes.map(printcodes)}\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Solution;"]},"metadata":{},"sourceType":"module"}