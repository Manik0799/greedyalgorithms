{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\GreedyAssignment\\\\assignment\\\\src\\\\Huffmann\\\\solution.js\";\nimport React from \"react\";\n\nfunction Solution(props) {\n  function HuffmanEncoding(str) {\n    this.str = str;\n    var count_chars = {};\n\n    for (var i = 0; i < str.length; i++) if (str[i] in count_chars) count_chars[str[i]]++;else count_chars[str[i]] = 1;\n\n    var pq = new BinaryHeap(function (x) {\n      return x[0];\n    });\n\n    for (var ch in count_chars) pq.push([count_chars[ch], ch]);\n\n    while (pq.size() > 1) {\n      var pair1 = pq.pop();\n      var pair2 = pq.pop();\n      pq.push([pair1[0] + pair2[0], [pair1[1], pair2[1]]]);\n    }\n\n    var tree = pq.pop();\n    this.encoding = {};\n\n    this._generate_encoding(tree[1], \"\");\n\n    this.encoded_string = \"\";\n    let counter = 0;\n\n    for (var i = 0; i < this.str.length; i++) {\n      if (counter >= 10) {\n        counter = 0;\n        this.encoded_string += \"\\n\";\n      }\n\n      this.encoded_string += this.encoding[str[i]];\n      counter++;\n    }\n  }\n\n  HuffmanEncoding.prototype._generate_encoding = function (ary, prefix) {\n    if (ary instanceof Array) {\n      this._generate_encoding(ary[0], prefix + \"0\");\n\n      this._generate_encoding(ary[1], prefix + \"1\");\n    } else {\n      this.encoding[ary] = prefix;\n    }\n  };\n\n  let individualcodes = [];\n\n  HuffmanEncoding.prototype.inspect_encoding = function () {\n    for (var ch in this.encoding) {\n      let sample = \"\";\n\n      if (ch === \" \") {\n        sample = \"Space\" + \" : \" + this.encoding[ch];\n      } else if (ch === \"\\n\") {\n        sample = \"Enter\" + \" : \" + this.encoding[ch];\n      } else {\n        sample = ch + \" : \" + this.encoding[ch];\n      }\n\n      individualcodes.push(sample);\n    }\n  }; // Binary heap implementation\n\n\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function (element) {\n      // Add the new element to the end of the array.\n      this.content.push(element); // Allow it to bubble up.\n\n      this.bubbleUp(this.content.length - 1);\n    },\n    pop: function () {\n      // Store the first element so we can return it later.\n      var result = this.content[0]; // Get the element at the end of the array.\n\n      var end = this.content.pop(); // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n\n      return result;\n    },\n    remove: function (node) {\n      var length = this.content.length; // To remove a value, we must search through the array to find\n      // it.\n\n      for (var i = 0; i < length; i++) {\n        if (this.content[i] != node) continue; // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n\n        var end = this.content.pop(); // If the element we popped was the one we needed to remove,\n        // we're done.\n\n        if (i == length - 1) break; // Otherwise, we replace the removed element with the popped\n        // one, and allow it to float up or sink down as appropriate.\n\n        this.content[i] = end;\n        this.bubbleUp(i);\n        this.sinkDown(i);\n        break;\n      }\n    },\n    size: function () {\n      return this.content.length;\n    },\n    bubbleUp: function (n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n],\n          score = this.scoreFunction(element); // When at 0, an element can not go up any further.\n\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n            parent = this.content[parentN]; // If the parent has a lesser score, things are in order and we\n        // are done.\n\n        if (score >= this.scoreFunction(parent)) break; // Otherwise, swap the parent with the current element and\n        // continue.\n\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        n = parentN;\n      }\n    },\n    sinkDown: function (n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n          element = this.content[n],\n          elemScore = this.scoreFunction(element);\n\n      while (true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2,\n            child1N = child2N - 1; // This is used to store the new position of the element,\n        // if any.\n\n        var swap = null; // If the first child exists (is inside the array)...\n\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n              child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n          if (child1Score < elemScore) swap = child1N;\n        } // Do the same checks for the other child.\n\n\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n              child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n        } // No need to swap further, we are done.\n\n\n        if (swap == null) break; // Otherwise, swap and continue.\n\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n    }\n  };\n  var huff = new HuffmanEncoding(props.data);\n\n  function getCode() {\n    huff.inspect_encoding();\n  }\n\n  function printcodes(letterCode) {\n    return /*#__PURE__*/React.createElement(\"h4\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 201,\n        columnNumber: 15\n      }\n    }, letterCode);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(\"b\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 17\n    }\n  }, \"Original text: \"), \" \", props.data, \" \"), /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 13\n    }\n  }), /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 15\n    }\n  }, /*#__PURE__*/React.createElement(\"b\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 19\n    }\n  }, \"Code : \"), \" \", huff.encoded_string), getCode(), /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 218,\n      columnNumber: 13\n    }\n  }), /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(\"b\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 17\n    }\n  }, \"Character codes : \"), \" \"), /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 220,\n      columnNumber: 13\n    }\n  }), individualcodes.map(printcodes));\n}\n\nexport default Solution;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/GreedyAssignment/assignment/src/Huffmann/solution.js"],"names":["React","Solution","props","HuffmanEncoding","str","count_chars","i","length","pq","BinaryHeap","x","ch","push","size","pair1","pop","pair2","tree","encoding","_generate_encoding","encoded_string","counter","prototype","ary","prefix","Array","individualcodes","inspect_encoding","sample","scoreFunction","content","element","bubbleUp","result","end","sinkDown","remove","node","n","score","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","child2Score","huff","data","getCode","printcodes","letterCode","map"],"mappings":"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","sourcesContent":["import React from \"react\";\r\n\r\nfunction Solution(props){\r\n\r\n\r\n    function HuffmanEncoding(str) {\r\n        this.str = str;\r\n     \r\n        var count_chars = {};\r\n        for (var i = 0; i < str.length; i++) \r\n            if (str[i] in count_chars) \r\n                count_chars[str[i]] ++;\r\n            else \r\n                count_chars[str[i]] = 1;\r\n     \r\n        var pq = new BinaryHeap(function(x){return x[0];});\r\n        for (var ch in count_chars) \r\n            pq.push([count_chars[ch], ch]);\r\n     \r\n        while (pq.size() > 1) {\r\n            var pair1 = pq.pop();\r\n            var pair2 = pq.pop();\r\n            pq.push([pair1[0]+pair2[0], [pair1[1], pair2[1]]]);\r\n        }\r\n     \r\n        var tree = pq.pop();\r\n        this.encoding = {};\r\n        this._generate_encoding(tree[1], \"\");\r\n     \r\n        this.encoded_string = \"\"\r\n        let counter= 0;\r\n        for (var i = 0; i < this.str.length; i++) {\r\n\r\n          if(counter>=10){\r\n            counter=0;\r\n            this.encoded_string+= \"\\n\";\r\n          }\r\n            this.encoded_string += this.encoding[str[i]];\r\n            counter++;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    HuffmanEncoding.prototype._generate_encoding = function(ary, prefix) {\r\n        if (ary instanceof Array) {\r\n            this._generate_encoding(ary[0], prefix + \"0\");\r\n            this._generate_encoding(ary[1], prefix + \"1\");\r\n        }\r\n        else {\r\n            this.encoding[ary] = prefix;\r\n        }\r\n    }\r\n\r\n    let individualcodes= [];\r\n     \r\n    HuffmanEncoding.prototype.inspect_encoding = function() {\r\n        for (var ch in this.encoding) {\r\n\r\n            let sample= \"\";\r\n            if(ch===\" \"){\r\n                 sample= \"Space\" + \" : \" + this.encoding[ch]\r\n            }else if(ch===\"\\n\"){\r\n                sample= \"Enter\" + \" : \" + this.encoding[ch]\r\n            }\r\n            else{\r\n                 sample=  ch + \" : \" + this.encoding[ch];\r\n            }\r\n            \r\n            individualcodes.push(sample);\r\n        }\r\n    }\r\n\r\n\r\n// Binary heap implementation\r\n    function BinaryHeap(scoreFunction){\r\n        this.content = [];\r\n        this.scoreFunction = scoreFunction;\r\n      }\r\n      \r\n      BinaryHeap.prototype = {\r\n        push: function(element) {\r\n          // Add the new element to the end of the array.\r\n          this.content.push(element);\r\n          // Allow it to bubble up.\r\n          this.bubbleUp(this.content.length - 1);\r\n        },\r\n      \r\n        pop: function() {\r\n          // Store the first element so we can return it later.\r\n          var result = this.content[0];\r\n          // Get the element at the end of the array.\r\n          var end = this.content.pop();\r\n          // If there are any elements left, put the end element at the\r\n          // start, and let it sink down.\r\n          if (this.content.length > 0) {\r\n            this.content[0] = end;\r\n            this.sinkDown(0);\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        remove: function(node) {\r\n          var length = this.content.length;\r\n          // To remove a value, we must search through the array to find\r\n          // it.\r\n          for (var i = 0; i < length; i++) {\r\n            if (this.content[i] != node) continue;\r\n            // When it is found, the process seen in 'pop' is repeated\r\n            // to fill up the hole.\r\n            var end = this.content.pop();\r\n            // If the element we popped was the one we needed to remove,\r\n            // we're done.\r\n            if (i == length - 1) break;\r\n            // Otherwise, we replace the removed element with the popped\r\n            // one, and allow it to float up or sink down as appropriate.\r\n            this.content[i] = end;\r\n            this.bubbleUp(i);\r\n            this.sinkDown(i);\r\n            break;\r\n          }\r\n        },\r\n      \r\n        size: function() {\r\n          return this.content.length;\r\n        },\r\n      \r\n        bubbleUp: function(n) {\r\n          // Fetch the element that has to be moved.\r\n          var element = this.content[n], score = this.scoreFunction(element);\r\n          // When at 0, an element can not go up any further.\r\n          while (n > 0) {\r\n            // Compute the parent element's index, and fetch it.\r\n            var parentN = Math.floor((n + 1) / 2) - 1,\r\n            parent = this.content[parentN];\r\n            // If the parent has a lesser score, things are in order and we\r\n            // are done.\r\n            if (score >= this.scoreFunction(parent))\r\n              break;\r\n      \r\n            // Otherwise, swap the parent with the current element and\r\n            // continue.\r\n            this.content[parentN] = element;\r\n            this.content[n] = parent;\r\n            n = parentN;\r\n          }\r\n        },\r\n      \r\n        sinkDown: function(n) {\r\n          // Look up the target element and its score.\r\n          var length = this.content.length,\r\n          element = this.content[n],\r\n          elemScore = this.scoreFunction(element);\r\n      \r\n          while(true) {\r\n            // Compute the indices of the child elements.\r\n            var child2N = (n + 1) * 2, child1N = child2N - 1;\r\n            // This is used to store the new position of the element,\r\n            // if any.\r\n            var swap = null;\r\n            // If the first child exists (is inside the array)...\r\n            if (child1N < length) {\r\n              // Look it up and compute its score.\r\n              var child1 = this.content[child1N],\r\n              child1Score = this.scoreFunction(child1);\r\n              // If the score is less than our element's, we need to swap.\r\n              if (child1Score < elemScore)\r\n                swap = child1N;\r\n            }\r\n            // Do the same checks for the other child.\r\n            if (child2N < length) {\r\n              var child2 = this.content[child2N],\r\n              child2Score = this.scoreFunction(child2);\r\n              if (child2Score < (swap == null ? elemScore : child1Score))\r\n                swap = child2N;\r\n            }\r\n      \r\n            // No need to swap further, we are done.\r\n            if (swap == null) break;\r\n      \r\n            // Otherwise, swap and continue.\r\n            this.content[n] = this.content[swap];\r\n            this.content[swap] = element;\r\n            n = swap;\r\n          }\r\n        }\r\n      };\r\n\r\n\r\n      var huff = new HuffmanEncoding(props.data);\r\n\r\n      function getCode(){\r\n        \r\n        huff.inspect_encoding();\r\n      }\r\n\r\n\r\n      function printcodes(letterCode){\r\n          return(\r\n              <h4>{letterCode}</h4>\r\n          )\r\n      }\r\n\r\n\r\n\r\n    return(\r\n        <div>\r\n            <h3><b>Original text: </b> {props.data} </h3>\r\n\r\n            <br></br>\r\n            \r\n            \r\n              <h3><b>Code : </b> {huff.encoded_string}</h3>\r\n            \r\n            \r\n            {getCode()}\r\n            <br></br>\r\n            <h3><b>Character codes : </b> </h3>\r\n            <br></br>\r\n            {individualcodes.map(printcodes)}\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Solution;"]},"metadata":{},"sourceType":"module"}