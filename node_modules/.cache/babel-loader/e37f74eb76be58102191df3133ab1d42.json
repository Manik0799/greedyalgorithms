{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Testing for string or number data type\n\n\nvar isId = function isId(x) {\n  return !!~['string', 'number'].indexOf(typeof x === 'undefined' ? 'undefined' : _typeof(x));\n};\n/**\n * Graph Data Structure\n */\n\n\nvar Dracula = function () {\n  function Dracula() {\n    _classCallCheck(this, Dracula);\n\n    this.nodes = {};\n    this.edges = [];\n  }\n  /**\n   * `create` for the `new` haters :)\n   *\n   * @returns {Dracula} a new graph instance\n   */\n\n\n  _createClass(Dracula, [{\n    key: 'addNode',\n\n    /**\n     * Add node if it doesn't exist yet.\n     *\n     * This method does not update an existing node.\n     * If you want to update a node, just update the node object.\n     *\n     * @param {string|number|object} id or node data\n     * @param {object|} nodeData (optional)\n     * @returns {Node} the new or existing node\n     */\n    value: function addNode(id, nodeData) {\n      // Node initialisation shorthands\n      if (!nodeData) {\n        nodeData = isId(id) ? {\n          id: id\n        } : id;\n      } else {\n        nodeData.id = id;\n      }\n\n      if (!nodeData.id) {\n        nodeData.id = (0, _uuid2.default)(); // Don't create a new node if it already exists\n      } else if (this.nodes[nodeData.id]) {\n        return this.nodes[nodeData.id];\n      }\n\n      nodeData.edges = [];\n      this.nodes[nodeData.id] = nodeData;\n      return nodeData;\n    }\n    /**\n     * @param {string|number|object} source node or ID\n     * @param {string|number|object} target node or ID\n     * @param {object|} (optional) edge data, e.g. styles\n     * @returns {Edge}\n     */\n\n  }, {\n    key: 'addEdge',\n    value: function addEdge(sourceNode, targetNode) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var source = this.addNode(sourceNode);\n      var target = this.addNode(targetNode);\n      var style = opts.style || opts;\n      var edge = {\n        style: style,\n        source: source,\n        target: target\n      };\n      this.edges.push(edge);\n      source.edges.push(edge);\n      target.edges.push(edge);\n      return edge;\n    }\n    /**\n     * @param {string|number|Node} node node or ID\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(node) {\n      var _this = this;\n\n      var id = isId(node) ? node : node.id;\n      node = this.nodes[id]; // Delete node from index\n\n      delete this.nodes[id]; // Delete node from all the edges\n\n      this.edges.forEach(function (edge) {\n        if (edge.source === node || edge.target === node) {\n          _this.removeEdge(edge);\n        }\n      });\n      return node;\n    }\n    /**\n     * Remove an edge by providing either two nodes (or ids) or the edge instance\n     * @param {string|number|Node|Edge} node edge, node or ID\n     * @param {string|number|Node} node node or ID\n     * @return {Edge}\n     */\n\n  }, {\n    key: 'removeEdge',\n    value: function removeEdge(source, target) {\n      var found = void 0; // Fallback to only one parameter\n\n      if (!target) {\n        target = source.target;\n        source = source.source;\n      } // Normalise node IDs\n\n\n      if (isId(source)) source = {\n        id: source\n      };\n      if (isId(target)) target = {\n        id: target // Find and remove edge\n\n      };\n      this.edges = this.edges.filter(function (edge) {\n        if (edge.source.id === source.id && edge.target.id === target.id) {\n          found = edge;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (found) {\n        found.source.edges = found.source.edges.filter(function (edge) {\n          return edge !== found;\n        });\n        found.target.edges = found.target.edges.filter(function (edge) {\n          return edge !== found;\n        });\n      } // Return removed edge\n\n\n      return found;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        nodes: this.nodes,\n        edges: this.edges\n      };\n    }\n  }], [{\n    key: 'create',\n    value: function create() {\n      return new Dracula();\n    }\n  }]);\n\n  return Dracula;\n}();\n\nexports.default = Dracula;","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/GreedyAssignment/assignment/node_modules/graphdracula/lib/dracula.js"],"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_typeof","Symbol","iterator","obj","constructor","_uuid","require","_uuid2","_interopRequireDefault","__esModule","default","_classCallCheck","instance","TypeError","isId","x","indexOf","Dracula","nodes","edges","addNode","id","nodeData","addEdge","sourceNode","targetNode","opts","arguments","undefined","source","style","edge","push","removeNode","node","_this","forEach","removeEdge","found","filter","toJSON","create"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIA,IAAIC,YAAY,GAAG,YAAY;AAAE,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,UAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4Bb,MAAAA,MAAM,CAACC,cAAP,CAAsBK,MAAtB,EAA8BI,UAAU,CAACI,GAAzC,EAA8CJ,UAA9C;AAA4D;AAAE;;AAAC,SAAO,UAAUK,WAAV,EAAuBC,UAAvB,EAAmCC,WAAnC,EAAgD;AAAE,QAAID,UAAJ,EAAgBX,gBAAgB,CAACU,WAAW,CAACG,SAAb,EAAwBF,UAAxB,CAAhB;AAAqD,QAAIC,WAAJ,EAAiBZ,gBAAgB,CAACU,WAAD,EAAcE,WAAd,CAAhB;AAA4C,WAAOF,WAAP;AAAqB,GAAhN;AAAmN,CAA9hB,EAAnB;;AAEA,IAAII,OAAO,GAAG,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA3D,GAAsE,UAAUC,GAAV,EAAe;AAAE,SAAO,OAAOA,GAAd;AAAoB,CAA3G,GAA8G,UAAUA,GAAV,EAAe;AAAE,SAAOA,GAAG,IAAI,OAAOF,MAAP,KAAkB,UAAzB,IAAuCE,GAAG,CAACC,WAAJ,KAAoBH,MAA3D,IAAqEE,GAAG,KAAKF,MAAM,CAACF,SAApF,GAAgG,QAAhG,GAA2G,OAAOI,GAAzH;AAA+H,CAA5Q;;AAEA,IAAIE,KAAK,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AAEA,IAAIC,MAAM,GAAGC,sBAAsB,CAACH,KAAD,CAAnC;;AAEA,SAASG,sBAAT,CAAgCL,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACM,UAAX,GAAwBN,GAAxB,GAA8B;AAAEO,IAAAA,OAAO,EAAEP;AAAX,GAArC;AAAwD;;AAE/F,SAASQ,eAAT,CAAyBC,QAAzB,EAAmChB,WAAnC,EAAgD;AAAE,MAAI,EAAEgB,QAAQ,YAAYhB,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIiB,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE,C,CAEzJ;;;AACA,IAAIC,IAAI,GAAG,SAASA,IAAT,CAAcC,CAAd,EAAiB;AAC1B,SAAO,CAAC,CAAC,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqBC,OAArB,CAA6B,OAAOD,CAAP,KAAa,WAAb,GAA2B,WAA3B,GAAyCf,OAAO,CAACe,CAAD,CAA7E,CAAV;AACD,CAFD;AAIA;;;;;AAIA,IAAIE,OAAO,GAAG,YAAY;AACxB,WAASA,OAAT,GAAmB;AACjBN,IAAAA,eAAe,CAAC,IAAD,EAAOM,OAAP,CAAf;;AAEA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,KAAL,GAAa,EAAb;AACD;AAED;;;;;;;AAOAlC,EAAAA,YAAY,CAACgC,OAAD,EAAU,CAAC;AACrBtB,IAAAA,GAAG,EAAE,SADgB;;AAIrB;;;;;;;;;;AAUAX,IAAAA,KAAK,EAAE,SAASoC,OAAT,CAAiBC,EAAjB,EAAqBC,QAArB,EAA+B;AACpC;AACA,UAAI,CAACA,QAAL,EAAe;AACbA,QAAAA,QAAQ,GAAGR,IAAI,CAACO,EAAD,CAAJ,GAAW;AAAEA,UAAAA,EAAE,EAAEA;AAAN,SAAX,GAAwBA,EAAnC;AACD,OAFD,MAEO;AACLC,QAAAA,QAAQ,CAACD,EAAT,GAAcA,EAAd;AACD;;AACD,UAAI,CAACC,QAAQ,CAACD,EAAd,EAAkB;AAChBC,QAAAA,QAAQ,CAACD,EAAT,GAAc,CAAC,GAAGd,MAAM,CAACG,OAAX,GAAd,CADgB,CAEhB;AACD,OAHD,MAGO,IAAI,KAAKQ,KAAL,CAAWI,QAAQ,CAACD,EAApB,CAAJ,EAA6B;AAClC,eAAO,KAAKH,KAAL,CAAWI,QAAQ,CAACD,EAApB,CAAP;AACD;;AACDC,MAAAA,QAAQ,CAACH,KAAT,GAAiB,EAAjB;AACA,WAAKD,KAAL,CAAWI,QAAQ,CAACD,EAApB,IAA0BC,QAA1B;AACA,aAAOA,QAAP;AACD;AAED;;;;;;;AAhCqB,GAAD,EAuCnB;AACD3B,IAAAA,GAAG,EAAE,SADJ;AAEDX,IAAAA,KAAK,EAAE,SAASuC,OAAT,CAAiBC,UAAjB,EAA6BC,UAA7B,EAAyC;AAC9C,UAAIC,IAAI,GAAGC,SAAS,CAACrC,MAAV,GAAmB,CAAnB,IAAwBqC,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AAEA,UAAIE,MAAM,GAAG,KAAKT,OAAL,CAAaI,UAAb,CAAb;AACA,UAAIrC,MAAM,GAAG,KAAKiC,OAAL,CAAaK,UAAb,CAAb;AACA,UAAIK,KAAK,GAAGJ,IAAI,CAACI,KAAL,IAAcJ,IAA1B;AACA,UAAIK,IAAI,GAAG;AAAED,QAAAA,KAAK,EAAEA,KAAT;AAAgBD,QAAAA,MAAM,EAAEA,MAAxB;AAAgC1C,QAAAA,MAAM,EAAEA;AAAxC,OAAX;AACA,WAAKgC,KAAL,CAAWa,IAAX,CAAgBD,IAAhB;AACAF,MAAAA,MAAM,CAACV,KAAP,CAAaa,IAAb,CAAkBD,IAAlB;AACA5C,MAAAA,MAAM,CAACgC,KAAP,CAAaa,IAAb,CAAkBD,IAAlB;AACA,aAAOA,IAAP;AACD;AAED;;;;;AAfC,GAvCmB,EA2DnB;AACDpC,IAAAA,GAAG,EAAE,YADJ;AAEDX,IAAAA,KAAK,EAAE,SAASiD,UAAT,CAAoBC,IAApB,EAA0B;AAC/B,UAAIC,KAAK,GAAG,IAAZ;;AAEA,UAAId,EAAE,GAAGP,IAAI,CAACoB,IAAD,CAAJ,GAAaA,IAAb,GAAoBA,IAAI,CAACb,EAAlC;AACAa,MAAAA,IAAI,GAAG,KAAKhB,KAAL,CAAWG,EAAX,CAAP,CAJ+B,CAK/B;;AACA,aAAO,KAAKH,KAAL,CAAWG,EAAX,CAAP,CAN+B,CAO/B;;AACA,WAAKF,KAAL,CAAWiB,OAAX,CAAmB,UAAUL,IAAV,EAAgB;AACjC,YAAIA,IAAI,CAACF,MAAL,KAAgBK,IAAhB,IAAwBH,IAAI,CAAC5C,MAAL,KAAgB+C,IAA5C,EAAkD;AAChDC,UAAAA,KAAK,CAACE,UAAN,CAAiBN,IAAjB;AACD;AACF,OAJD;AAKA,aAAOG,IAAP;AACD;AAED;;;;;;;AAlBC,GA3DmB,EAoFnB;AACDvC,IAAAA,GAAG,EAAE,YADJ;AAEDX,IAAAA,KAAK,EAAE,SAASqD,UAAT,CAAoBR,MAApB,EAA4B1C,MAA5B,EAAoC;AACzC,UAAImD,KAAK,GAAG,KAAK,CAAjB,CADyC,CAEzC;;AACA,UAAI,CAACnD,MAAL,EAAa;AACXA,QAAAA,MAAM,GAAG0C,MAAM,CAAC1C,MAAhB;AACA0C,QAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACD,OANwC,CAOzC;;;AACA,UAAIf,IAAI,CAACe,MAAD,CAAR,EAAkBA,MAAM,GAAG;AAAER,QAAAA,EAAE,EAAEQ;AAAN,OAAT;AAClB,UAAIf,IAAI,CAAC3B,MAAD,CAAR,EAAkBA,MAAM,GAAG;AAAEkC,QAAAA,EAAE,EAAElC,MAAN,CACzB;;AADyB,OAAT;AAEhB,WAAKgC,KAAL,GAAa,KAAKA,KAAL,CAAWoB,MAAX,CAAkB,UAAUR,IAAV,EAAgB;AAC/C,YAAIA,IAAI,CAACF,MAAL,CAAYR,EAAZ,KAAmBQ,MAAM,CAACR,EAA1B,IAAgCU,IAAI,CAAC5C,MAAL,CAAYkC,EAAZ,KAAmBlC,MAAM,CAACkC,EAA9D,EAAkE;AAChEiB,UAAAA,KAAK,GAAGP,IAAR;AACA,iBAAO,KAAP;AACD;;AACD,eAAO,IAAP;AACD,OANc,CAAb;;AAOF,UAAIO,KAAJ,EAAW;AACTA,QAAAA,KAAK,CAACT,MAAN,CAAaV,KAAb,GAAqBmB,KAAK,CAACT,MAAN,CAAaV,KAAb,CAAmBoB,MAAnB,CAA0B,UAAUR,IAAV,EAAgB;AAC7D,iBAAOA,IAAI,KAAKO,KAAhB;AACD,SAFoB,CAArB;AAGAA,QAAAA,KAAK,CAACnD,MAAN,CAAagC,KAAb,GAAqBmB,KAAK,CAACnD,MAAN,CAAagC,KAAb,CAAmBoB,MAAnB,CAA0B,UAAUR,IAAV,EAAgB;AAC7D,iBAAOA,IAAI,KAAKO,KAAhB;AACD,SAFoB,CAArB;AAGD,OAzBwC,CA0BzC;;;AACA,aAAOA,KAAP;AACD;AA9BA,GApFmB,EAmHnB;AACD3C,IAAAA,GAAG,EAAE,QADJ;AAEDX,IAAAA,KAAK,EAAE,SAASwD,MAAT,GAAkB;AACvB,aAAO;AAAEtB,QAAAA,KAAK,EAAE,KAAKA,KAAd;AAAqBC,QAAAA,KAAK,EAAE,KAAKA;AAAjC,OAAP;AACD;AAJA,GAnHmB,CAAV,EAwHR,CAAC;AACHxB,IAAAA,GAAG,EAAE,QADF;AAEHX,IAAAA,KAAK,EAAE,SAASyD,MAAT,GAAkB;AACvB,aAAO,IAAIxB,OAAJ,EAAP;AACD;AAJE,GAAD,CAxHQ,CAAZ;;AA+HA,SAAOA,OAAP;AACD,CA/Ia,EAAd;;AAiJAlC,OAAO,CAAC2B,OAAR,GAAkBO,OAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Testing for string or number data type\nvar isId = function isId(x) {\n  return !!~['string', 'number'].indexOf(typeof x === 'undefined' ? 'undefined' : _typeof(x));\n};\n\n/**\n * Graph Data Structure\n */\n\nvar Dracula = function () {\n  function Dracula() {\n    _classCallCheck(this, Dracula);\n\n    this.nodes = {};\n    this.edges = [];\n  }\n\n  /**\n   * `create` for the `new` haters :)\n   *\n   * @returns {Dracula} a new graph instance\n   */\n\n\n  _createClass(Dracula, [{\n    key: 'addNode',\n\n\n    /**\n     * Add node if it doesn't exist yet.\n     *\n     * This method does not update an existing node.\n     * If you want to update a node, just update the node object.\n     *\n     * @param {string|number|object} id or node data\n     * @param {object|} nodeData (optional)\n     * @returns {Node} the new or existing node\n     */\n    value: function addNode(id, nodeData) {\n      // Node initialisation shorthands\n      if (!nodeData) {\n        nodeData = isId(id) ? { id: id } : id;\n      } else {\n        nodeData.id = id;\n      }\n      if (!nodeData.id) {\n        nodeData.id = (0, _uuid2.default)();\n        // Don't create a new node if it already exists\n      } else if (this.nodes[nodeData.id]) {\n        return this.nodes[nodeData.id];\n      }\n      nodeData.edges = [];\n      this.nodes[nodeData.id] = nodeData;\n      return nodeData;\n    }\n\n    /**\n     * @param {string|number|object} source node or ID\n     * @param {string|number|object} target node or ID\n     * @param {object|} (optional) edge data, e.g. styles\n     * @returns {Edge}\n     */\n\n  }, {\n    key: 'addEdge',\n    value: function addEdge(sourceNode, targetNode) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var source = this.addNode(sourceNode);\n      var target = this.addNode(targetNode);\n      var style = opts.style || opts;\n      var edge = { style: style, source: source, target: target };\n      this.edges.push(edge);\n      source.edges.push(edge);\n      target.edges.push(edge);\n      return edge;\n    }\n\n    /**\n     * @param {string|number|Node} node node or ID\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(node) {\n      var _this = this;\n\n      var id = isId(node) ? node : node.id;\n      node = this.nodes[id];\n      // Delete node from index\n      delete this.nodes[id];\n      // Delete node from all the edges\n      this.edges.forEach(function (edge) {\n        if (edge.source === node || edge.target === node) {\n          _this.removeEdge(edge);\n        }\n      });\n      return node;\n    }\n\n    /**\n     * Remove an edge by providing either two nodes (or ids) or the edge instance\n     * @param {string|number|Node|Edge} node edge, node or ID\n     * @param {string|number|Node} node node or ID\n     * @return {Edge}\n     */\n\n  }, {\n    key: 'removeEdge',\n    value: function removeEdge(source, target) {\n      var found = void 0;\n      // Fallback to only one parameter\n      if (!target) {\n        target = source.target;\n        source = source.source;\n      }\n      // Normalise node IDs\n      if (isId(source)) source = { id: source };\n      if (isId(target)) target = { id: target\n        // Find and remove edge\n      };this.edges = this.edges.filter(function (edge) {\n        if (edge.source.id === source.id && edge.target.id === target.id) {\n          found = edge;\n          return false;\n        }\n        return true;\n      });\n      if (found) {\n        found.source.edges = found.source.edges.filter(function (edge) {\n          return edge !== found;\n        });\n        found.target.edges = found.target.edges.filter(function (edge) {\n          return edge !== found;\n        });\n      }\n      // Return removed edge\n      return found;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return { nodes: this.nodes, edges: this.edges };\n    }\n  }], [{\n    key: 'create',\n    value: function create() {\n      return new Dracula();\n    }\n  }]);\n\n  return Dracula;\n}();\n\nexports.default = Dracula;"]},"metadata":{},"sourceType":"script"}